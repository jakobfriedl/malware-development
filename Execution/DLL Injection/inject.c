#include "header.h"

BOOL GetRemoteProcess(IN LPWSTR szProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess) {

    // According to the documentation:
    // Before calling the Process32First function, set this member to sizeof(PROCESSENTRY32).
    // If dwSize is not initialized, Process32First fails.
    PROCESSENTRY32	Proc      = { .dwSize = sizeof(PROCESSENTRY32) };
    HANDLE          hSnapShot = NULL;

    // Takes a snapshot of the currently running processes 
    hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
    if (hSnapShot == INVALID_HANDLE_VALUE) {
        printf("[!] CreateToolhelp32Snapshot Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    // Retrieves information about the first process encountered in the snapshot.
    if (!Process32First(hSnapShot, &Proc)) {
        printf("[!] Process32First Failed With Error : %d \n", GetLastError());
        goto _EndOfFunction;
    }

    do {
        CHAR LowerName[MAX_PATH * 2]; 

        if (Proc.szExeFile) {
            DWORD	dwSize = lstrlenW(Proc.szExeFile);
            DWORD   i = 0;

            RtlSecureZeroMemory(LowerName, MAX_PATH * 2);

            // Converting each charachter in Proc.szExeFile to a lower case character
            // and saving it in LowerName
            if (dwSize < MAX_PATH * 2) {

                for (; i < dwSize; i++) {
                    LowerName[i] = (WCHAR)tolower(Proc.szExeFile[i]);
                }
                LowerName[i++] = '\0';
            }
        }

        // If the lowercase'd process name matches the process we're looking for
        if (strcmp(LowerName, szProcessName) == 0) {
            // Save the PID
            *dwProcessId = Proc.th32ProcessID;

            // Open a handle to the process
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, Proc.th32ProcessID);
            if (*hProcess == NULL)
                printf("[!] OpenProcess Failed With Error : %d \n", GetLastError());

            break;
        }

        // Retrieves information about the next process recorded the snapshot.
        // While a process still remains in the snapshot, continue looping
    } while (Process32Next(hSnapShot, &Proc));
   
    // Cleanup
_EndOfFunction:
    if (hSnapShot != NULL)
        CloseHandle(hSnapShot);
    if (*dwProcessId == NULL || *hProcess == NULL)
        return FALSE;
    return TRUE;
}

BOOL InjectDll(IN HANDLE hProcess, IN LPCWSTR szDllPath, IN CONST SIZE_T sSize) {

    BOOL    bState = TRUE;
    DWORD   dwThreadId = 0;
    SIZE_T  sBytesWritten = 0;
    PVOID   pBuffer = NULL;
    PVOID   pLoadLibraryW = NULL;
    HANDLE  hThread = NULL;

    pLoadLibraryW = GetProcAddress(GetModuleHandleW(L"Kernel32.dll"), "LoadLibraryW");
    if (NULL == pLoadLibraryW) {
        PRINT_ERROR("GetProcAddress");
        bState = FALSE; goto CLEANUP;
    }
    OKAY("[0x%p] obtained the address of LoadLibraryW!", pLoadLibraryW);

    pBuffer = VirtualAllocEx(hProcess, NULL, sSize, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
    if (NULL == pBuffer) {
        PRINT_ERROR("VirtualAllocEx");
        bState = FALSE; goto CLEANUP;
    }
    OKAY("[0x%p] [RW-] allocated a buffer with PAGE_READWRITE [RW-] permissions!", pBuffer);

    if (!WriteProcessMemory(hProcess, pBuffer, szDllPath, sSize, &sBytesWritten)) {
        PRINT_ERROR("WriteProcessMemory");
        bState = FALSE; goto CLEANUP;
    }
    OKAY("[0x%p] [RW-] wrote %zu-bytes to the allocated buffer", pBuffer, sBytesWritten);

    hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibraryW, pBuffer, 0, &dwThreadId);
    if (NULL == hThread) {
        PRINT_ERROR("CreateRemoteThread");
        bState = FALSE; goto CLEANUP;
    }

    OKAY("[0x%p] successfully created a thread (%ld)!", hThread, dwThreadId);
    INFO("[0x%p] waiting for the thread to finish execution...", hThread);
    WaitForSingleObject(hThread, INFINITE);
    OKAY("[0x%p] thread finished execution, beginning cleanup...", hThread);

CLEANUP:

    if (hThread) {
        CloseHandle(hThread);
        INFO("[0x%p] closed handle on thread", hThread);
    }

    if (hProcess) {
        CloseHandle(hProcess);
        INFO("[0x%p] closed handle on process", hProcess);
    }

    if (pBuffer) {
        VirtualFree(pBuffer, 0, MEM_RELEASE);
        INFO("[0x%p] allocated buffer freed", pBuffer);
    }

    return bState;
}

int main(int argc, char* argv[]) {

    DWORD  dwProcessId = NULL; 
    HANDLE hProcess    = NULL; 
    LPWSTR processName = NULL; 

    if (argc < 3) {
        WARN("Usage: %s [target-process] [dll]\n", argv[0]); 
        return ERROR; 
    }

    // Get process to inject into 
    if (!GetRemoteProcess(argv[1], &dwProcessId, &hProcess)) {
        WARN("Error fetching process %s: %d", argv[1], GetLastError());
        return ERROR; 
    }
    OKAY("Process %s found with PID %d at handle 0x%p", argv[1], dwProcessId, hProcess);

    if (!InjectDll(hProcess, DLL, sizeof(DLL))) {
        WARN("Injection failed"); 
    }

	return 0; 
}