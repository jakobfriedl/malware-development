#include "base.h"

BOOL SelfDelete() {

    BOOL bState = TRUE;

    WCHAR szPath[MAX_PATH * 2] = { 0 };
    FILE_DISPOSITION_INFO Delete = { 0 };

    PFILE_RENAME_INFO pRename = NULL;
    LPCWSTR lpNewStream = L":NEW"; 
    SIZE_T sStreamLenght = wcslen(lpNewStream) * sizeof(wchar_t); 
    SIZE_T sRename = sizeof(FILE_RENAME_INFO) + sStreamLenght; 

    HANDLE hFile = INVALID_HANDLE_VALUE; 

    /// Setup
    // Allocate buffer for FILE_RENAME_INFO structure
    pRename = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sRename); 
    if (!pRename) {
        PRINT_ERROR("HeapAlloc");
        bState = FALSE;
        goto CLEANUP; 
    }

    // Cleanup structures
    ZeroMemory(&szPath, sizeof(szPath)); 
    ZeroMemory(&Delete, sizeof(FILE_DISPOSITION_INFO));
    
    // Mark file for deletion
    Delete.DeleteFile = TRUE; 

    // Set new data stream name buffer and size in the FILE_RENAME_INFO structure
    pRename->FileNameLength = sStreamLenght; 
    RtlCopyMemory(pRename->FileName, lpNewStream, sStreamLenght); 

    // Get current file name
    if (!GetModuleFileNameW(NULL, szPath, MAX_PATH * 2)) {
        PRINT_ERROR("GetModuleFileNameW");
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY_W(L"Got current file name: %s.", szPath); 

    /// Rename data stream
    // Retrieve file handle using CreateFile
    hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL); 
    if (hFile == INVALID_HANDLE_VALUE) {
        PRINT_ERROR("CreateFile [1]"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Got file handle.", hFile); 

    // Rename 
    if (!SetFileInformationByHandle(hFile, FileRenameInfo, pRename, sRename)) {
        PRINT_ERROR("SetFileInformationByHandle [1]"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY_W(L"Renamed :DATA to %s.", lpNewStream); 

    CloseHandle(hFile); 

    /// Deleting the data stream
    // Open file handle again
    hFile = CreateFileW(szPath, DELETE | SYNCHRONIZE, FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
    if (hFile == INVALID_HANDLE_VALUE) {
        PRINT_ERROR("CreateFile [2]");
        bState = FALSE;
        goto CLEANUP;
    }
    OKAY("[ 0x%p ] Got file handle.", hFile);

    // Mark for deletion after file handle is closed
    if (!SetFileInformationByHandle(hFile, FileDispositionInfo, &Delete, sizeof(Delete))) {
        PRINT_ERROR("SetFileInformationByHandle [2]");
        bState = FALSE;
        goto CLEANUP; 
    }
    
    CloseHandle(hFile); 
    
    OKAY("Deleted."); 

CLEANUP: 

    HeapFree(GetProcessHeap(), 0, pRename); 

    return bState; 
}

int wmain(int argc, wchar_t* argv[]) {

    if (IsDebuggerPresent()) {
        WARN("Debugger detected, self-deleting..."); 
        if (!SelfDelete()) {
            PRINT_ERROR("SelfDelete"); 
            return EXIT_FAILURE; 
        }
    }

    return EXIT_SUCCESS;
}